# 6.1 功能的实现
- **搞清业务逻辑**
![[]I}]UII(O8Y3%BO_K~@7%3L.png]]
- **thrift接口的实现步骤**
![[0[%Y204AR6GSO~LQW6]DD5G.png]]
---
1.定义接口`match_thrift`: https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift
2.用接口实现节点
- 服务端的实现: https://thrift.apache.org/tutorial/cpp.html, 需要将skeleton赋值到main.cpp中
- 客户端的实现: https://thrift.apache.org/tutorial/py.html, 直接生成的服务端，需要删除Match-remote

# 6.2 注意事项
![[3_Z$~Q~B~H8@PS8}YLS6[~P.png]]
1. 定义接口时，最好传入一些额外信息`string info`，之后可以将想传的信息放入`info`当中，`info`可以序列化一个`.json`，可以避免更改接口。一般一个`info`就够用了，当需要多个`info`时，则需要去修改接口。

2. 写thrift时，先编译跑通，然后逐步往里添加模块。

3. 编译：g++ -c "所有想编译的文件"。

4. 链接：g++ \*.o -o main，此处需要用到thrift的动态链接库，即`g++ *.o -o main -lthrift`；再用到thread，即`g++ *.o -o main -lthrift -pthread*`。

5. 执行：./\*.cpp，如./main.cpp。

6. 最好不要将`.o`和可执行文件推送到git中。用`git restore --stage *.o`将`.o`删除，可执行文件操作类似。`.pyc`，`.swp`同样删除。

7. 做一个项目时，最好将实现路径记录下来。

8. 使用`thrift`时，最好使用相同版本。

9. 此处，接收请求和匹配的功能是独立的，需要多线程来实现。

10. 多线程执行时，线程间的执行顺序是随机的。单个线程内部的语句是顺序执行的，但多个线程之间的语句在执行过程中可能会交叉执行。为了解决这种问题，引入了信号量。在线程对共享资源进行操作时，通过信号量使其独占资源，避免别的线程同时修改。

11. 



# 6.3 知识点
1. mutex
```md
#include <mutex>

struct Task
{
	User user;
	string type;
};

struct MessageQueue
{
	queue<Task> q;
	mutex m;
	condition_varibale cv;
}message_queue;

unique_lock<mutex> lck(message_queue.m);

lck.unlock();
```
2. condition_variable
```md
#include <condition_variable>

struct Task
{
	User user;
	string type;
};

struct MessageQueue
{
	queue<Task> q;
	mutex m;
	condition_varibale cv;
}message_queue;

message_queue.cv.notify_one(); //message_queue.cv.notify_all()

message_queue.cv.wait(lck);
```
3. thread
```md
#include <thread>

void consume_task()
{
	//
}

thread matching_thread(consume_task);
```





