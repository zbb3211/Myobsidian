# 209. 长度最小的子数组
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        # 时间复杂度：O(n)
        # 空间复杂度：O(1)
        n = len(nums)
        ans = inf
        s, left = 0, 0
        # 枚举右端点
        for right, x in enumerate(nums):
            s += x
            while s >= target:  # 左端点是否能右移
                ans = min(ans, right - left + 1)
                s -= nums[left]  
                left += 1
        return ans if ans <= n else 0
```

# 713. 乘积小于K的子数组
```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0

        # [l, r]符合条件，则[l + 1, r],...,[r, r]均符合条件
        # 连续子数组的数目为r - l + 1
        n = len(nums)
        left, prod = 0, 1
        ans = 0

        # 枚举右端点
        for right, x in enumerate(nums):
            prod *= x
            # 找到当前右端点符合条件下对应的左端点
            while prod >= k:
                prod //= nums[left]
                left += 1
            ans += right - left + 1
        return ans
```

# 3. 无重复字符的最长字串
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = 0
        cnt = Counter()
        left = 0
        for right, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 1:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, right - left + 1)
        return ans
```

# 课后习题
## 1004. 最大连续 1 的个数
滑动窗口
统计窗口内 0 的个数 $\textit{cnt}_0​$，则问题转换成在$\textit{cnt}_0\le k$ 的前提下，窗口大小的最大值。
```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        ans = left = cnt = 0
        for right, x in enumerate(nums):
            cnt += 1 - x
            while cnt > k:
                cnt -= 1 - nums[left]
                left += 1
            ans = max(ans, right - left + 1)
        return ans
```
## 1234. 替换子串得到平衡字符串
## 1658. 将 x 减到 0 的最小操作数
