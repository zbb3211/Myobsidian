# 基础算法
## 快速排序
```md
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```
## 归并排序
```md
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;

    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
## 二分
- 有单调性一定可以二分，但可以二分未必具有单调性。
- 二分是可以找到某种性质，将整个区间一分为二，一半满足，一半不满足。二分可以寻找性质的边界，既可以寻找左边界，也可以寻找右边界。
- ![[1678262208805.png]]
```md
整数二分
//区间[l, r]被划分为[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r)
{
	while (l < r)
	{
		int mid = l + r >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	return l;
}

//区间[l, r]被划分为[l, mid - 1]和[mid, r]时使用
int bsearch_2(int l, int r)
{
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		// 如果l = r - 1, mid = l + r >> 1 -> mid = l, 如果check(mid) == true, l = mid = l, 会死循环。
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
	return l;
}

浮点数二分
double l = 0, r = x;
while (r - l >= 1e-6)	//保留4位小数,1e-6,依次类推
{
	double mid = (l + r) / 2;
	if (mid * mid >= x) r = mid;
	else l = mid;
}
```
## 高精度
> A + B
> A - B
> A * a
> A / B
### 高精度加法
- 运算时会有进位，从低位开始比较方便。
![[1678869069788.png]]
![[1678869206473.png]]
```cpp
vector<int> add(vector<int> &a, vector<int> &b)
{
    vector<int> c;
    
    if (a.size() < b.size()) swap(a, b);
    
    int t = 0;  // 进位
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i];
        if (i < b.size()) t += b[i];
        c.push_back(t % 10);
        t /= 10;
    }
    if (t) c.push_back(t);
    
    return c;
    
}
```
### 高精度减法
![[1678883495195.png]]
```cpp
vector<int> sub(vector<int> &a, vector<int> &b)
{
    vector<int> c;
    
    for (int i = 0, t = 0; i < a.size(); i ++ )
    {
        t = a[i] - t;  //t：借位
        if (i < b.size()) t -= b[i];
        c.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
    
}
```
- 高精度减法需要考虑到两个数的大小关系
```cpp
bool cmp(vector<int> &a, vector<int> &b)
{
    if (a.size() != b.size()) return a.size() > b.size();
    
    for (int i = a.size() - 1; i >= 0; i -- )
        if (a[i] != b[i])
            return a[i] > b[i];
    return true;
}

if (cmp(a, b)) c = sub(a, b);
else
{
	cout << '-';
	c = sub(b, a);
}
```
### 高精度乘法
![[1678887836543.png]]
```cpp
vector<int> mul(vector<int> &a, int b)
{
    vector<int> c;
    
    int t = 0;
    for (int i = 0; i < a.size() || t; i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
}
```
### 高精度除法
![[1678889293597.png]]
```cpp
vector<int> div(vector<int> &a, int b, int &r)
{
    vector<int> c;
    
    r = 0;  //余数
    for (int i = a.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + a[i];
        c.push_back(r / b);
        r %= b;
    }
    
    reverse(c.begin(), c.end());
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
    
}
```
## 前缀和与差分
### 前缀和
#### 一维前缀和
![[1678890758552.png]]
```cpp
s[0] = 0;
for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i];
```
#### 二维前缀和
- 求正方形区域的值
![[1678891586023.png]]
- 初始化正方形区域的值
![[1678891733045.png]]
![[1678891700383.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = 1; j <= m; j ++ )
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];  //求前缀和
		
while (q -- )
{
	int x1, y1, x2, y2;
	scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
	printf("%d\n", s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]);  //算部分和
}
```
## 双指针算法
##### 思路
![[8@1MXM5~E7CP3AT`E928)AC.png|450]]
##### 代码模板
```md
for (int i = 0, j = 0; i < n; i ++ )
{
	while (j < i && check(i, j)) j ++ ;
		
	//每道题的具体逻辑
}
```
## 位运算
##### 思路
![[1667998221203.png|450]]
##### 代码模板
```md

```
## lowbit运算
##### 思路
![[1667998637311.png|450]]
##### 代码模板
```md
例子：
x = 1010, lowbit(x) = 10
x = 101000, lowbit(x) = 1000

int lowbit(int x)
{
	return x & -x;
}
```
## 整数离散化
##### 思路
![[1668151863421.png|450]]

##### 代码模板
```md
vector<int> alls; //存储所有待离散化的值
sort(alls.begin(), alls.end()); //将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end()) //去掉重复元素

//二分求出x对应的离散化的值
int find(int x)
{
	int l = 0, r = alls.size() - 1;
	while (l < r)
	{
		int mid = l + r >> 1;
		if (alls[mid] >= x) r = mid;
		else l = mid + 1;
	}
	return r + 1; //映射到1，2，...，n
}
```
## unique函数的实现
##### 思路
![[1668409071138.png|450]]
##### 代码模板
```md
vector<int>::iterator unique(vector<int> &a)
{
	int j = 0;
	for (int i = 0; i < a.size(); i ++ )
		if (!i || a[i] != a[i - 1])
			a[j ++ ] = a[i];
	//a[0]~a[j - 1]所有的a中不重复的数
	
	return a.begin() + j;
}
```
## 区间合并
##### 思路
![[1668410498000.png|450]]
##### 代码模板
```md
void merge(vector<PII> &segs)
{
    vector<PII> res;
    
    sort(segs.begin(), segs.end());
    
    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});    //当前区间无合并范围，存入res
            st = seg.first, ed = seg.second;    //更新当前需要维护的区间
        }
        else
            ed = max(ed, seg.second);   //合并区间

    if (st != -2e9) res.push_back({st, ed});    //最后一个区间，直接存入res
    
    segs = res;
    
}
```
## 搜索与图论
### 朴素Dijkstra
##### 思路
```md
1. dist[1] = 0, dist[i] = +∞
2. for i : 1 ~ n	//每次确定一个点的最短距离，n次循环
		t <- 不在s中的距离最近的点
		s <- t	//s：当前已确定最短距离的点
		用t更新其他点的距离
```

## 动态规划
### 记忆化搜索
![[1678274302847.png]]

