- 时间复杂度：状态量 * 转移计算量
# 背包问题
## 01背包
![[1681915448797.png]]
![[1681915760155.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = m; j >= v[i]; j -- )
		f[j] = max(f[j], f[j - v[i]] + w[i]);
```
## 完全背包
![[1681972334452.png]]
### 朴素做法
```cpp
for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
```

### 优化
![[1681972947379.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = 0; j <= m; j ++ )
	{
		f[i][j] = f[i - 1][j];
		if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
	}
```
### 转换成一维
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = v[i]; j <= m; j ++ )
		f[j] = max(f[j], f[j - v[i]] + w[i]);
```

## 多重背包
### 朴素做法
```cpp
for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k <= s[i] && k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
```

### 优化
```cpp
int cnt = 0;
for (int i = 1; i <= n; i ++ )
{
	int a, b, s;
	cin >> a >> b >> s;
	int k = 1;
	while (k <= s)
	{
		cnt ++ ;
		v[cnt] = a * k;
		w[cnt] = b * k;
		s -= k;
		k *= 2;
	}
	if (s > 0)
	{
		cnt ++ ;
		v[cnt] = a * s;
		w[cnt] = b * s;
	}
}

n = cnt;

for (int i = 1; i <= n; i ++ )
	for (int j = m; j >= v[i]; j -- )
		f[j] = max(f[j], f[j - v[i]] + w[i]);
```
## 分组背包
![[1681975887214.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = m; j >= 0; j -- )
		for (int k = 0; k < s[i]; k ++ )
			if (v[i][k] <= j)
				f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```
# 线性DP
## 数字三角形
![[1682133531938.png]]
### 自顶向下
```cpp
for (int i = 2; i <= n; i ++ )
	for (int j = 1; j <= i; j ++ )
		f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);
```

### 自底向上
```cpp
for (int i = n - 1; i >= 1; i -- )
	for (int j = 1; j <= i; j ++ )
		f[i][j] = max(f[i + 1][j + 1], f[i + 1][j]) + f[i][j];
```

## 最长上升子序列
![[1682135677707.png]]
```cpp
for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1;  // 只有a[i]一个数
        for (int j = 1; j < i; j ++ )
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
    }
    
```
### 保存状态转移的路径
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n;
int a[N], f[N], g[N];

int main()
{
    cin >> n;
    
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1;  // 只有a[i]一个数
        // g[i] = 0;
        for (int j = 1; j < i; j ++ )
            if (a[j] < a[i])
                if (f[i] < f[j] + 1)
                {
                    f[i] = f[j] + 1;
                    g[i] = j;
                }
    }
    
    int k = 1;
    for (int i = 1; i <= n; i ++ )
        if (f[k] < f[i])
            k = i;
    printf("%d\n", f[k]);
    
    for (int i = 0, len = f[k]; i < len; i ++ )
    {
        printf("%d ", a[k]);
        k = g[k];
    }
    
    return 0;
}
```

## 最长上升子序列Ⅱ
- 存储每种长度的最长上升子序列末尾的最小值；长度相同，末尾值大的能拓展长度，则末尾值小的也必定能拓展。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N], q[N];

int main()
{
    cin >> n;
    
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    
    int len = 0;
    for (int i = 0; i < n; i ++ )
    {
        int l = 0, r = len;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        
        len = max(len, r + 1);
        q[r + 1] = a[i]; 
    }
    
    cout << len << endl;
    
    return 0;
}
```

## 最长公共子序列
![[1682157333184.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = 1; j <= m; j ++ )
	{
		f[i][j] = max(f[i - 1][j], f[i][j - 1]);
		if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
	}
```

## 最短编辑距离
![[1682220487247.png]]
```cpp
int edit_distance(char a[], char b[])
{
    int la = strlen(a + 1), lb = strlen(b + 1);

	// a的长度为0时，与b匹配只能进行插入操作
    for (int i = 0; i <= lb; i ++ ) f[0][i] = i;
    // b的长度为0时，与b匹配只能进行删除操作
    for (int i = 0; i <= la; i ++ ) f[i][0] = i;
    
    for (int i = 1; i <= la; i ++ )
        for (int j = 1; j <= lb; j ++ )
        {
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);  // 删除和插入
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j]));  // 修改
        }
        
    return f[la][lb];
}
```

## 编辑距离
```cpp
// int edit_distance() 最短编辑距离

for (int i = 0; i < n; i ++ )
	if (edit_distance(str[i], s) <= limit)
		// 实现内容
```
# 区间DP
## 石子合并
![[1682164466575.png]]
![[1682164503517.png]]
```cpp
for (int len = 2; len <= n; len ++ )  // 枚举合并区间的长度
	for (int i = 1; i + len - 1 <= n; i ++ )  // 枚举左端点
	{
		int l = i, r = i + len - 1;
		f[l][r] = 1e8;
		for (int k = l; k < r; k ++ )  // 两侧区间的分隔位置
			f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
	}
```
# 计数类DP
## 整数划分
### 完全背包思路
![[1682321782337.png]]
![[1682321888555.png]]
```cpp
for (int i = 1; i <= n; i ++ )
	for (int j = i; j <= n; j ++ )
		f[j] = (f[j] + f[j - i]) % mod;
```

### 分拆数
![[1682322333807.png]]
# 数位统计DP
## 计数问题
最重要的是分情况讨论
![[Pasted image 20230320164025.png]]
当某个区间不好求时，可以考虑前缀和的做法
x > 0 时：
![[1679303040803.png]]
x = 0 时：需要考虑前导零，例如0000123，不是一个合法的格式
对于第(2)种状况无影响，对于(1)：
![[1679303406990.png]]
```cpp
int get(vector<int> num, int l, int r)
{
    int res = 0;
    for (int i = l; i >= r; i -- ) res = res * 10 + num[i];
    return res;
}

int pow10(int x)
{
    int res = 1;
    while (x -- ) res *= 10;
    return res;
}

int count(int n, int x)
{
    if (!n) return 0;

    vector<int> num;
    while (n)
    {
        num.push_back(n % 10);
        n /= 10;
    }
    n = num.size();

    int res = 0;
    for (int i = n - 1 - !x; i >= 0; i -- )  // 如果最高位是0，从第二位开始枚举
    {   
        // 第一类情况
        if (i < n - 1)
        {
            res += get(num, n - 1, i + 1) * pow10(i);  // 000~abc-1,x,000~999
            if (!x) res -= pow10(i);  // 去除前导零的影响，从001~abc-1; 不能000,x(0)
        }

        // 第二类情况
        if (num[i] == x) res += get(num, i - 1, 0) + 1;
        else if (num[i] > x) res += pow10(i);
    }

    return res;

}
```

# 状态压缩DP
## 蒙德里安的梦想
![[1682325570826.png]]
```cpp
// 初始化st数组，表示每个状态内连续的0是否为偶数个
for (int i = 0; i < 1 << n; i ++ )
{
	int cnt = 0;
	st[i] = true;
	for (int j = 0; j < n; j ++ )
		if (i >> j & 1)  // 第j行为1，判断前面连续空格的个数
		{
			if (cnt & 1) st[i] = false;  // 奇数个
			cnt = 0;
		}
		else cnt ++ ;  // 空格加1
	if (cnt & 1) st[i] = false;
}

// 枚举所有合法状态，选出符合要求的
for (int i = 0; i < 1 << n; i ++ )
{
	state[i].clear();  // 多组数据，需要先将上一组的状况清除
	for (int j = 0; j < 1 << n; j ++ )
		if ((i & j) == 0 && st[i | j])  // 同一行不能同时放，i-1列有连续偶数个空格
			state[i].push_back(j);  // 把方案存入state

}

memset(f, 0, sizeof f);
f[0][0] = 1;
for (int i = 1; i <= m; i ++ )
	for (int j = 0; j < 1 << n; j ++ )
		for (auto k : state[j])  // 遍历合法状态
			f[i][j] += f[i - 1][k];

cout << f[m][0] << endl;

```

## 最短Hamilton的路径
![[1682327817311.png]]
```cpp
memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    
// f[i][j]：从0到j所走的路径为i的二进制表示
for (int i = 1; i < 1 << n; i += 2)  // 因为起点固定是0，因此最低位必须要是1，即i是奇数
	for (int j = 0; j < n; j ++ )
		if (i >> j & 1)  // 路径中包含j
			for (int k = 0; k < n; k ++ )  
				if (i >> k & 1)  // 0~j的路径中包含k
					f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
```
# 树形DP
## 没有上司的舞会
![[1682335079734.png]]
![[1682335105987.png]]

```cpp
void dfs(int u)
{
    f[u][1] = happy[u];
    
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        dfs(j);
        
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0], f[j][1]);
    }
}
```

# 记忆化搜索
## 滑雪
![[1678274302847.png]]
```cpp
int dp(int x, int y)
{
    int &v = f[x][y];
    if (v != -1) return v;
    
    v = 1;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        
        if (a >= 1 && a <= n && b >= 1 && b <= m && h[a][b] < h[x][y])
            v = max(v, dp(a, b) + 1);
    }
    
    return v;
}
```
