# 质数
质数：在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数或者素数。
## 质数的判定——试除法(O(sqrt(n)))
![[1681130916673.png]]
```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    
    for (int i = 2; i <= x / i; i ++ )  // 写成i * i <= x, 可能会溢出
        if (x % i == 0)
            return false;
    return true;
}
```
## 分解质因数——试除法(O(sqrt(n)))
n中最多只包含一个大于$\sqrt{n}$的质因子，如果有至少两个， 则相乘会超过n
```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)  // i一定是质数，算到i时，已经将2~i-1中的质数给分解出去了
        {
            int cnt = 0;
            while (x % i == 0)
            {
                x /= i;
                cnt ++ ;
            }
            cout << i << ' ' << cnt << endl;
        }
    
    if (x > 1) printf("%d %d\n", x, 1);  // 特判大于sqrt(n)的那个质数
    puts("");
}
```
## 筛质数
### 埃氏筛法
把质数的倍数掉
```cpp
void get_primes(int x)
{
    for (int i = 2; i <= x; i ++ )
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            for (int j = i + i; j <= n; j += i) st[j] = true;
        }
}
```
### [[线性筛-欧拉筛]]
只会被最小质因子筛掉
- i % primes[j] == 0 
	-  primes[j]一定是i的最小质因子，primes[j]也一定是primes[j] * i的最小质因子
- i % primes[j] != 0
	-  primes[j]一定小于i的所有质因子，primes[j]也一定是primes[j] * i的最小质因子
```cpp
void get_primes(int x)
{
    for (int i = 2; i <= x; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= x / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;  
        }
    }
}
```

# 约数
## 试除法求一个数的所有约数
```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    
    sort(res.begin(), res.end());
    
    return res;
}
```
## 约数个数
![[Pasted image 20230412203524.png]]
![[1681302939557.png]]
```cpp
unordered_map<int, int> primes;
    
while (n -- )
{
	int x;
	cin >> x;
	
	for (int i = 2; i <= x / i; i ++ )
		while (x % i == 0)
		{
			x /= i;
			primes[i] ++ ;
		}
	
	if (x > 1) primes[x] ++ ;
}

LL res = 1;
for (auto p : primes) res = res * (p.second + 1) % mod;
```


## 约数之和
![[1681303109702.png]]
```cpp
unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto prime : primes)
    {
        int p = prime.first, a = prime.second;
        LL t = 1;
        
        while (a -- ) t = (t * p + 1) % mod;
        res = res * t % mod;
    }

```
## 欧几里得算法/辗转相除法
```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
两个数的最小公倍数=两者之积除以两者的最大公约数
# 欧拉函数
## 公式法
![[1681371728711.png]]
![[1681372016736.png]]
![[1681371972011.png]]
```cpp
int res = a;
for (int i = 2; i <= a / i; i ++ )
	if (a % i == 0)
	{
		res = res / i * (i - 1);
		while (a % i == 0) a /= i;
	}

if (a > 1) res = res / a * (a - 1);
```

## 筛法求欧拉函数
```cpp
LL get_eulers(int n)
{
    phi[1] = 1;
    
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            phi[i] = i - 1;
        }
        
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            
            if (i % primes[j] == 0)
            {
                phi[primes[j] * i] = phi[i] * primes[j];
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
    
    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += phi[i];
    
    return res;
}
```
## 欧拉定理
![[1681374126068.png]]
# [[快速幂]]
时间复杂度：$O(log k)$
思路：预处理出$a^{2^{0}}$ mod p ... $a^{2^{log k}}$ mod p 的结果，将k用二进制表示，把值为1的那些位相乘。
![[1683876907908.png]]
![[1681890960007.png]]
![[1681892103072.png]]
```cpp
// a ^ k % p
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    
    return res;
}
```
## 快速幂求逆元
![[1683870707081.png]]
求$b \cdot x = 1(mod\text{ }m)$，x是b的逆元。
对于质数p，根据费马小定理，有$b^{p - 1}=1(mod \text{ } p)$，即有$b \cdot b^{p - 2}=1(mod \text{ }p)$。此时，b的逆元是$b^{p-2}$


# 扩展欧几里得算法
![[1681893497906.png]]
![[1681894336898.png]]
扩展欧几里得算法求的是系数x, y
```cpp
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```
# 中国剩余定理
![[1681895363553.png]]
![[1682411957570.png]]
![[1682412247248.png]]


# 高斯消元
![[1683721907596.png]]
![[1683722250702.png]]
```cpp
int gauss()  // 高斯消元，答案存于a[i][n]中，0 <= i < n
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )  // 枚举每列
    {
        int t = r;
        for (int i = r; i < n; i ++ )  // 找绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
                
        if (fabs(a[t][c]) < eps) continue;  // 全部是0，换一列
        
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);  // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];  // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )  // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }
    
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2;  // 无解
        return 1;  // 有无穷多组解
    }
    
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    
    return 0;  // 有唯一解
}
```

## 高斯消元解异或线性方程组
![[1683991410801.png]]
# 求组合数
![[1683726765176.png]]
![[1683727007805.png]]
数据范围不同，采用的方法不同
## 求组合数Ⅰ
10w询问，1 <= a, b <= 2000，递推；时间复杂度：$O(N^{2})$

```cpp
void init()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
}
```

## 求组合数Ⅱ
1w询问，1 <= a, b <= 10w，预处理；时间复杂度：$O(NlogN)$
![[1683815820230.png]]
对于除法用逆元来处理

```cpp
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    
    return res;
}

// 初始化
fact[0] = infact[0] = 1; 
for (int i = 1; i < N; i ++ )
{
	fact[i] = (LL)fact[i - 1] * i % mod;
	infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}

// 结果
(LL)fact[a] * infact[a - b] % mod * infact[b] % mod)
```

## 求组合数Ⅲ
20询问，1 <= a, b <= $10^{8}$，1 <= p <= $10^{5}$；时间复杂度：$O(log_{p}^{N}plogp)$
Lucas定理：
![[1683885084328.png]]
```cpp
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        k >>= 1;
        a = (LL) a * a % p;
    }
    
    return res;
}

int C(int a, int b, int p)
{
    if (b > a) return 0;
    
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++ , j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2, p) % p;
    }
    
    return res;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

lucas(a, b, p);
```

## 求组合数Ⅳ
思路：
1. 筛素数
2. 求每个质数的次数
![[1683893003609.png]]
3. 高精度乘法把所有质因子乘起来
```cpp
// 线性筛
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

// 求p,p^2, ... 的总个数
int get(int n, int p)
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    
    return res;
}

// 高精度乘
vector<int> mul(vector<int> &a, int b)
{
    vector<int> c;
    
    int t = 0;
    for (int i = 0, t = 0; i < a.size() || t; i ++ )
    {
        if (i < a.size()) t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    
    return c;
}

get_primes(a);
    
for (int i = 0; i < cnt; i ++ )
{
	int p = primes[i];
	sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )
	for (int j = 0; j < sum[i]; j ++ )
		res = mul(res, primes[i]);
		
for (int i = res.size() - 1; i >= 0; i -- ) printf("%d", res[i]);
```
## 满足条件的01序列
![[1683982492196.png]]
序列对应一条路径，要求任意前缀序列中 0 的个数都不少于 1 的个数。对应到路径当中，即任意位置，x >= y。
![[1683982728398.png]]
任意一条合法路径不能经过红线。

所有经过红线到(6, 6)的路径，关于红线做轴对称，可以转换成到(5, 7)的路径。
![[1683983272953.png]]
结果是卡特兰数：$\frac{C_{2n}^{n}}{n + 1}$

```cpp
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        k >>= 1;
        a = (LL)a * a % p;
    }
    
    return res;
}

int a = 2 * n, b = n;
int res = 1;

for (int i = a; i > a - b; i -- ) res = (LL)res * i % mod;
for (int i = 1; i <= b; i ++ ) res = (LL)res * qmi(i, mod - 2, mod) % mod;

res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;
```
# 容斥原理
## 能被整除的数
![[1683985121600.png]]
```cpp
for(int i = 1; i < 1 << m; i++) {
	int t = 1;             //选中集合对应质数的乘积
	int s = 0;             //选中的集合数量

	//枚举当前状态的每一位
	for(int j = 0; j < m; j++){
		//选中一个集合
		if(i >> j & 1){
			//乘积大于n, 则n/t = 0, 跳出这轮循环
			if((LL)t * p[j] > n){    
				t = -1;
				break;
			}
			s++;                  //有一个1，集合数量+1
			t *= p[j];
		}
	}

	if(t == -1) continue;  

	if(s & 1) res += n / t;              //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量
	else res -= n / t;                      //反之则为 -1
}
```
# 博弈论
![[1683988606202.png]]
## Nim游戏
![[1683987858885.png]]

证明：对于第二种情况，一定有一种取法可以使得下一步变成先手必败状态。
![[1683988162215.png]]

证明：对于第一种情况，不论什么取法，下一步一定变成先手必胜状态。即不论怎么拿，都会变成第二种情况。
![[1683988474933.png]]
## 台阶-Nim游戏
![[1683993450649.png]]

## 集合-Nim游戏
![[1683988927592.png]]
![[1683989167293.png]]
![[1683989465043.png]]

```cpp
int sg(int x)
{
    if (f[x] != -1) return f[x];

    unordered_set<int> S;
    for (int i = 0; i < m; i ++ )
    {
        int sum = s[i];
        if (x >= sum) S.insert(sg(x - sum));
    }

    //选出最小的没有出现的自然数
    for (int i = 0;; i ++ )
        if (!S.count(i))
            return f[x] = i;
}

memset(f, -1, sizeof f);

int res = 0;
cin >> n;
for (int i = 0; i < n; i ++ )
{
	int x;
	cin >> x;
	res ^= sg(x);
}
```

## 拆分-Nim游戏
![[1683993904899.png]]
```cpp
int sg(int x)
{
	if (f[x] != -1) return f[x];

	unordered_set<int> S;
	for (int i = 0; i < x; i ++ )
		for (int j = 0; j <= i; j ++ )
			S.insert(sg(i) ^ sg(j));

	for (int i = 0; ; i ++ )
		if (!S.count(i))
			return f[x] = i;
}
```