# [[快速排序]]
```md
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```
# [[归并排序]]
```md
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;

    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
# [[二分查找]]
- 有单调性一定可以二分，但可以二分未必具有单调性。
- 二分是可以找到某种性质，将整个区间一分为二，一半满足，一半不满足。二分可以寻找性质的边界，既可以寻找左边界，也可以寻找右边界。
- ![[1678262208805.png]]
## 整数二分
```cpp
//区间[l, r]被划分为[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r)
{
	while (l < r)
	{
		int mid = l + r >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	return l;
}

//区间[l, r]被划分为[l, mid - 1]和[mid, r]时使用
int bsearch_2(int l, int r)
{
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		// 如果l = r - 1, mid = l + r >> 1 -> mid = l, 如果check(mid) == true, l = mid = l, 会死循环。
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
	return l;
}
```

## 浮点数二分
```cpp
double l = 0, r = x;
while (r - l >= 1e-8)	//保留6位小数,1e-8,依次类推
{
	double mid = (l + r) / 2;
	if (mid * mid * mid >= x) r = mid;
	else l = mid;
}
```
# 高精度
## 高精度加法
- 运算时会有进位，从低位开始比较方便。
![[1678869069788.png]]
![[1678869206473.png]]
```cpp
vector<int> add(vector<int> &a, vector<int> &b)
{
    vector<int> c;
    
    if (a.size() < b.size()) swap(a, b);
    
    int t = 0;  // 进位
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i];
        if (i < b.size()) t += b[i];
        c.push_back(t % 10);
        t /= 10;
    }
    if (t) c.push_back(t);
    
    return c;
    
}
```
## 高精度减法
![[1678883495195.png]]
```cpp
vector<int> sub(vector<int> &a, vector<int> &b)
{
    vector<int> c;
    
    for (int i = 0, t = 0; i < a.size(); i ++ )
    {
        t = a[i] - t;  //t：借位
        if (i < b.size()) t -= b[i];
        c.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
    
}
```
- 高精度减法需要考虑到两个数的大小关系
```cpp
bool cmp(vector<int> &a, vector<int> &b)
{
    if (a.size() != b.size()) return a.size() > b.size();
    
    for (int i = a.size() - 1; i >= 0; i -- )
        if (a[i] != b[i])
            return a[i] > b[i];
    return true;
}

if (cmp(a, b)) c = sub(a, b);
else
{
	cout << '-';
	c = sub(b, a);
}
```
## 高精度乘法
![[1678887836543.png]]
```cpp
vector<int> mul(vector<int> &a, int b) //保持了与add相似的格式
{
    vector<int> c;

    int t = 0;
    for (int i = 0; i < a.size() || t; i ++ )
    {
        if (i < a.size()) t += a[i] * b; 
        c.push_back(t % 10);
        t /= 10;
    }

    while (c.size() > 1 && c.back() == 0) c.pop_back();

    return c;

}
```
## 高精度除法
![[1678889293597.png]]
```cpp
vector<int> div(vector<int> &a, int b, int &r)
{
    vector<int> c;
    
    r = 0;  //余数
    for (int i = a.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + a[i];  // 实现不足向后移位的效果
        c.push_back(r / b);
        r %= b;
    }
    
    reverse(c.begin(), c.end());
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    
    return c;
    
}
```

# 前缀和
## 一维前缀和
![[1678890758552.png]]
```cpp
// 两个数组
for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

s[0] = 0;
for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i];

// 对单个数组
for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]);

for (int i = 1; i <= n; i ++ ) s[i] += s[i - 1];
```

```md
# lc 2559
令s[i + 1] = 前i项和比较好计算
对于[left, right]，有s[right + 1] - s[left]
```
## 二维前缀和
- 求正方形区域的值
![[1678891586023.png]]
- 初始化正方形区域的值
![[1678891733045.png]]
![[1678891700383.png]]
> - **二维前缀和的构建**
> 二维数组的前缀和，每个维度都与前一项有关，所以要分别对两个维度进行操作，因此是$s[i - 1][j] + s[i][j - 1]$, 再减去多加上的重叠部分，即$s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]$。
> - **计算部分和**
>	计算部分和同样也需要考虑到两个维度，分别减去两个维度上的和，因此为$s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2]$, 再加上多减去的重叠部分，即$s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]$

```cpp
// 求前缀和

// 两个数组
for (int i = 1; i <= n; i ++ )
	for (int j = 1; j <= m; j ++ )
		scanf("%d", &a[i][j])

for (int i = 1; i <= n; i ++ )
	for (int j = 1; j <= m; j ++ )
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; 

// 对单个数组
for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &s[i][j]);

for (int i = 1; i <= n; i ++ )
    for (int j = 1; j <= m; j ++ )
        s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

//算部分和
while (q -- )
{
	int x1, y1, x2, y2;
	scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
	printf("%d\n", s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]);  
}
```
# 差分
## 一维差分
![[1679917527455.png]]
- a是b的前缀和，b是a的差分
- 如果想在a[l, r] + c, 由于a是b的前缀和，因此只需要b[l] + c, b[r + 1] - c
```cpp
void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}
```

## 二维差分
![[1679919874441.png]]
```cpp
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y2 + 1] += c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y1] -= c;
}
```

# 双指针算法
## 思路
![[8@1MXM5~E7CP3AT`E928)AC.png|450]]
- 先写一个暴力枚举
- 看i，j之间是否存在单调关系，对遍历进行优化
### 代码模板
```md
for (int i = 0, j = 0; i < n; i ++ )
{
	while (j < i && check(i, j)) j ++ ;
		
	//每道题的具体逻辑
}
```

## 判断子序列
> 当a[i] == b[j], 子序列的指针才会向右移动；不论如何，b序列的指针都需要向后移动一步

```cpp
bool check(string a, string b)
{
	int n = a.size(), m = b.size();
	int i = 0, j = 0;
	while (i < n && j < m)
	{
		if (a[i] == b[j]) i ++ ;
		j ++ ;
	}

	if (i == n) return true;
	return false;
}
```
# 位运算
## 思路
![[1667998221203.png|450]]
## 代码模板
```md
n >> k & 1
```

# lowbit运算
## 思路
![[1667998637311.png|450]]
## 代码模板
```cpp
/*
x = 1010, lowbit(x) = 10
x = 101000, lowbit(x) = 1000
*/

int lowbit(int x)
{
	return x & -x;
}
```

# 整数离散化
## 思路
![[1668151863421.png|450]]
![[1679924858367.png]]

## 代码模板
```cpp
vector<int> alls; //存储所有待离散化的值
sort(alls.begin(), alls.end()); //将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end()) //去掉重复元素

//二分求出x对应的离散化的值
int find(int x)
{
	int l = 0, r = alls.size() - 1;
	while (l < r)
	{
		int mid = l + r >> 1;
		if (alls[mid] >= x) r = mid;
		else l = mid + 1;
	}
	return r + 1; //映射到1，2，...，n
}
```
## unique函数的实现
### 思路
![[1668409071138.png|450]]
### 代码模板
```md
vector<int>::iterator unique(vector<int> &a)
{
	int j = 0;
	for (int i = 0; i < a.size(); i ++ )
		if (!i || a[i] != a[i - 1])
			a[j ++ ] = a[i];
	//a[0]~a[j - 1]所有的a中不重复的数
	
	return a.begin() + j;
}
```

# 区间合并
## 思路
![[1668410498000.png|450]]
##### 代码模板
```c++
void merge(vector<PII> &segs)
{
    vector<PII> res;
    
    sort(segs.begin(), segs.end());
    
    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});    //当前区间无合并范围，存入res
            st = seg.first, ed = seg.second;    //更新当前需要维护的区间
        }
        else
            ed = max(ed, seg.second);   //合并区间

    if (st != -2e9) res.push_back({st, ed});    //最后一个区间，直接存入res
    
    segs = res;
    
}
```



