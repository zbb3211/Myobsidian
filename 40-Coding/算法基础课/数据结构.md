# 单链表
> AcWing:
> - 826

常采用邻接表的形式，用于存储树和图
![[1680152394002.png]]
![[1680152550313.png]]
```cpp
/*
head 表示头结点的下标
e[i] 表示节点i的值
ne[i] 表示节点i的next指针是多少
idx 存储当前已经用到了哪个点
*/
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;  // 第k个数的下标为k - 1
}

// 将x插到头结点
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}

// 将x插到下标是k的点后面
void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}

// 将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}

// 对于删除操作，需要特判删除头节点的状况
if (!k) head = ne[head];
else remove(k - 1);
```

# 双链表
> AcWing:
> - 827

用于优化某些问题
![[1680155241636.png]]
```cpp
void init()
{
    r[0] = 1;
    l[1] = 0;
    idx = 2;  // 因此第k个数的下标为k + 1;
}

void insert(int k, int x)
{
    e[idx] = x;
    l[idx] = k, r[idx] = r[k];
    l[r[k]] = idx, r[k] = idx ++ ;
}

void remove(int k)
{
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}
```
# 栈
> AcWing:
> - 828、3302
![[1680159070823.png]]
## 表达式求值
> Acwing:
> - 3302
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<stack>
#include<unordered_map>
using namespace std;

//双栈
stack<int>num;
stack<char>op;

//求值函数,使用末尾的运算符操作末尾的两个数
void eval()
{
    auto b = num.top(); num.pop();//第二个操作数
    auto a = num.top(); num.pop();//第一个操作数
    auto c = op.top(); op.pop();  //运算符

    int x;                        //结果计算(注意顺序)
    if (c == '+')x = a + b;
    else if (c == '-')x = a - b;
    else if (c == '*')x = a * b;
    else x = a / b;
    num.push(x);                  //结果入栈
}

int main()
{
    //优先级表
    unordered_map<char, int>pr{ {'+',1},{'-',1},{'*',2},{'/',2} };

    //读入表达式
    string str;
    cin >> str;

    //从前往后扫描表达式
    for (int i = 0; i < str.size(); i++)
    {
        auto c = str[i];
        //扫描到数字,使用双指针法一直读入
        if (isdigit(c))
        {
            //j表示扫描到数字的指针
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j++] - '0';
            //更新i指针
            i = j - 1;
            //数字入栈
            num.push(x);
        }
        //左括号直接入栈
        else if (c == '(')op.push(c);
        //右括号出现,从右往左计算栈中数据,直到遇见左括号
        else if (c == ')')
        {
            //不断使用eval函数对末尾数字运算
            while (op.top() != '(')eval();
            //弹出左括号
            op.pop();
        }
        //扫描到运算符
        else
        {
            //如果栈顶运算符优先级较高,先操作栈顶元素再入栈
            while (op.size() && pr[op.top()] >= pr[c])eval();
            //如果栈顶运算符优先级较低,直接入栈
            op.push(c);
        }
    }
    //把没有操作完的运算符从右往左操作一遍
    while (op.size())eval();
    //栈顶元素为最终答案
    cout << num.top() << endl;
    return 0;
}
```

# 队列
> AcWing:
> - 829
![[1680159224271.png]]

# 单调栈
>常见应用情形：给定一个序列，求序列中每一个数左边离它最近且比它小的数的位置。诸如此类模型。
## 求每个数左边第一个比它小的数
```c++
// AcWing 830 

int stk[N];
int tt;

for (int i = 0; i < n; i ++ )
{
	while (tt != -1 && stk[tt] >= x) tt -- ;
	if (tt) cout << stk[tt];
	stk[ ++ tt] = x;
}
```

## 求每个数右边第一个比它小的数
```c++
// AcWing 4738
stack<int> stk;
stk.push(n + 1), p[n + 1] = -1e9;

for (int i = n; i >= 0; i -- )
{
	while (p[stk.top()] >= p[i]) stk.pop();
	r[i + 1] = stk.top();
	stk.push(i);
}
```

# 单调队列
> AcWing:
> - 154

- 求滑动窗口内的最值问题

> 单调栈与单调队列问题的常规思路：
> 1. 考虑用栈或队列暴力模拟原问题。
> 2. 思考暴力模拟方法中，栈或队列内部哪些元素是无用的。
> 3. 删除无用元素，看是否存在单调性。
> 4. 存在单调性的话，可以从端点取极值，也可以通过二分查找一个值。


# KMP
> AcWing:
> - 831

kmp的思路：
1. 朴素算法
```cpp
s[N], p[M];

for (int i = 1; i <= n; i ++ )
{
	bool flag = true;
	for (int j = 1; j <= m; j ++ )
		if (s[i] != p[j])
		{
			flag = false;
			break;
		}
}
```
2. 如何优化
- next[i]：前i个字母构成的字符串中，最长的与前缀相等的后缀长度
	next[i] = j，指p[i, j] == p[i - j + 1, i]
![[1680347583861.png]]
	挪到虚线前有几个next[i]个字母。第一次是next[5]=2，因此挪到虚线前有两个字母；第二次是next[3]=1，因此挪到虚线前有一个字母。
- 求next[]实际上就是用p和自己的子串比较
![[1680348798342.png]]
```cpp
 
// 求next过程
for (int i = 2, j = 0; i <= n; i ++ )
{
	while (j && p[i] != p[j + 1]) j = ne[j];
	
	if (p[i] == p[j + 1]) j ++ ;
	ne[i] = j;
}

// kmp匹配的过程
for (int i = 1, j = 0; i <= m; i ++ )
{
	while (j && s[i] != p[j + 1]) j = ne[j];
	
	if (s[i] == p[j + 1]) j ++ ;
	if (j == n)
	{
		printf("%d ", i - n);  // 匹配成功的字符串所在位置的第一个下标
		j = ne[j];  // 匹配成功后，求下一个匹配需要更新的位置
	}
}
```

# Trie
> AcWing:
> - 835, 143
- 高效地存储和查找字符串集合的数据结构
## Trie树的存储
![[1679645835418.png]]
标记以当前字母结尾存在单词
## Trie树的查找
按路径查找，看节点是否都存在。若存在，则看结尾是否有标记。
```cpp
void insert(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    
    cnt[p] ++ ;
    
}

int query(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    
    return cnt[p];
    
}
```
一维是结点总数，而结点和结点之间的关系（谁是谁儿子）存在第二个维度，比如[0][1]=3, [0]表示根节点，[1]表示它有一个儿子‘b’,这个儿子的下标是3；接着如果有一个[3][2]=8 ; 说明根节点的儿子‘b’也有一个儿子‘c’，这个孙子的下标就是8；这样传递下去，就是一个字符串。

# 并查集
> AcWing:
> - 240、836、837

并查集的作用：
- 将两个集合合并
- 询问两个元素是否在一个集合中
![[1680439112208.png]]
```cpp
int find(int x)  // 返回x的祖宗节点+路径压缩
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 并查集初始化
for (int i = 1; i <= n; i ++ ) p[i] = i;
```
## 带权并查集 
### AcWing 240
![[1680498189182.png]]
0->1, 1->2, 2->0
只需要知道每个节点与根节点的关系，即可知道两个节点的关系。
```cpp
#include <iostream>

using namespace std;

const int N = 50010;

int p[N], d[N];

int find(int x)
{
    if (p[x] != x)
    {
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }

/*
*   if (p[x] != x)
*   {
*       d[x] += d[p[x]];  // 没有先求出p[x]，无法保证d[x] += d[p[x]]是x到根节点的距离
*       p[x] = find(p[x]); 
*   } 
*/

    return p[x];

}

int main()
{
    int n, m;
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) p[i] = i;

    int res = 0;
    while (m -- )
    {
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);

        if (x > n || y > n) res ++ ;
        else
        {
            int px = find(x), py = find(y);
            if (t == 1)
            {
                if (px == py && (d[x] - d[y]) % 3) res ++ ;
                else if (px != py)
                {
                    p[px] = py;
                    d[px] = d[y] - d[x]; // (d[x] + d[px] - d[y]) % 3 == 0, 计算p[x]在新树中的距离
                }
            }
            else
            {
                if (px == py && (d[x] - d[y] - 1) % 3) res ++ ;
                else if (px != py)
                {
                    p[px] = py;
                    d[px] = d[y] + 1 - d[x];
                }
            }
        }
    }

    cout << res << endl;

    return 0;

}
```

# 堆
![[1680442688592.png]]
![[1680442239775.png]]
```cpp
// 小根堆
void down(int u)
{
    int t = u;
    if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        swap(h[u], h[t]);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u / 2] > h[u])
    {
        swap(h[u / 2], h[u]);
        u /= 2;
    }
}
```
```cpp
// 需要带索引的版本
void heap(int a, int b)
{
	swap(ph[hp[a]], ph[hp[b]]);
	swap(hp[a], hp[b]);
	swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(h[u], h[t]);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u / 2] > h[u])
    {
        heap_swap(h[u / 2], h[u]);
        u /= 2;
    }
}
```

# 哈希表
![[Pasted image 20230403165711.png]]

## 拉链法
```cpp
void insert(int x)
{
    int k = (x % N + N) % N;

    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++ ;
}

bool find(int x)
{
    int k = (x % N + N) % N;

    for (int i = h[k]; ~i; i = ne[i])
        if (e[i] == x)
            return true;
    return false;
}
```

## 开放寻址法
```cpp
int find(int x)
{
    int k = (x % N + N) % N;

    while (h[k] != null && h[k] != x)
    {
        k ++ ;
        if (k == N) k = 0;
    }

    return k;

}

memset(h, 0x3f, sizeof h);
```

## 字符串前缀哈希
![[1680529158797.png]]
将字符串变成p进制的数字：
![[1680529200248.png]]
假设上述和为sum，需要sum mod Q将其映射到0~Q-1
- 字符串很长，对应的数太大，通过模 2^64 把它映射到 [0, 2^64 - 1]
- 用 unsigned long long 存储，溢出相当于对 2^64 取模，省略了手动运算
![[1680529428549.png]]

求L-R这段的哈希值
![[1680529577023.png]]

```cpp
typedef unsigned long long ULL;

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
	p[i] = p[i - 1] * P;
	h[i] = h[i - 1] * P + str[i];
}
```

# C++ STL
```cpp
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```
