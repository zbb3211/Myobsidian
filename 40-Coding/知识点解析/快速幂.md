# 1. 概念
**平方求幂**（英语：exponentiating by squaring）或**快速幂**是快速计算一个数（或更一般地说，一个[半群](https://zh.wikipedia.org/wiki/%E5%8D%8A%E7%BE%A4 "半群")的元素，如[多项式](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A0%85%E5%BC%8F "多项式")或[方阵](https://zh.wikipedia.org/wiki/%E6%96%B9%E5%9D%97%E7%9F%A9%E9%98%B5 "方块矩阵")）的大[正整数](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0 "自然数")乘[幂](https://zh.wikipedia.org/wiki/%E5%B9%82 "幂")的一般方法。

# 2. 基本方法
对于正整数n，可知
![{\displaystyle x^{n}={\begin{cases}x\,(x^{2})^{\frac {n-1}{2}},&{\mbox{if }}n{\mbox{ is odd}}\\(x^{2})^{\frac {n}{2}},&{\mbox{if }}n{\mbox{ is even}}.\end{cases}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/46fe9e68c70c04df4c3d22c469a57d4655b50539)
该方法使用指数的位（二进制的位，即bit）来确定计算哪些幂。

此例显示如何使用此方法计算 $x^13$。 幂指数13的二进制为1101。这些位按照从左到右的顺序使用。 指数有4位，所以有4次迭代。

首先，将结果化为1：$r\leftarrow 1\,(=x^{0})$
1. $r \leftarrow r^2\,(=x^{0})$，第1位=1，所以计算$r\leftarrow r\cdot x(=x^{1})$。 
2. $r \leftarrow r^{2}\,(=x^{2})$，第2位=1，所以计算$r \leftarrow r \cdot x(=x^{3})$。
3. $r \leftarrow r^{2}\,(=x^{6})$，第3位=0，所以这一步什么也不做。
4. $r \leftarrow r^{2}\,(=x^{12})$，第4位=1，所以计算$r \leftarrow r \cdot x(=x^{13})$。

该算法的递归实现：
```md
Function exp_by_squaring(x, n)
    if n < 0  then return exp_by_squaring(1 / x, -n);
    else if n = 0  then return  1;
    else if n = 1  then return  x ;
    else if n is even  then return exp_by_squaring(x * x,  n / 2);
    else if n is odd  then return x * exp_by_squaring(x * x, (n - 1) / 2);
```

c++实现（非递归）返回$p^{n}$对Mod求模
```cpp
long long power(long long p, long long n)
{
	long long ans = 1;
	while (n)
	{
		if (n & 1) ans = (ans * p) % Mod;
		p = p * p % Mod;
		n >>= 1;
	}
	return ans;
}
```

# 3. 计算复杂度
简要分析表明此算法用了$\lfloor \log_{2}n\rfloor$ 次平方，以及至多$\lfloor log_{2}n \rfloor$ 次乘法，其中$\lfloor \rfloor$表示[向下取整函数](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E7%AC%A6%E8%99%9F "高斯符号")。更确切地说，做乘法的次数比n的[二进制展开](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6 "二进制")的次数要少一次。对于n大于4左右的时候，这种算法在计算上就已经比天真地将它与自身重复地相乘更高效了。

每次平方的结果大约是前一次结果的两倍，因此，如果两个d位数的相乘的实现要进行$O(d^{k})$次计算（其中k为一固定值），那么计算$x^{n}$的复杂度为：
![{\displaystyle \sum \limits _{i=0}^{O(\log(n))}(2^{i}O(\log(x)))^{k}=O((n\log(x))^{k})}](https://wikimedia.org/api/rest_v1/media/math/render/svg/878f92c78f8f09a1b19bd3a706214ef79a380945)
