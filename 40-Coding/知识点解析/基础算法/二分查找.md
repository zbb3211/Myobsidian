# 1.概念
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6 "计算机科学")中，**二分查找算法**（英语：binary search algorithm），也称**折半搜索算法**（英语：half-interval search algorithm）、**对数搜索算法**（英语：logarithmic search algorithm），是一种在[有序数组](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E6%95%B0%E5%AF%B9 "有序数对")中查找某一特定元素的搜索[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95 "算法")。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

二分查找算法在[最坏情况](https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5&action=edit&redlink=1)下是[对数时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#%E5%AF%B9%E6%95%B0%E6%97%B6%E9%97%B4 "时间复杂度")的，需要进行$O(logn)$次比较操作（n在此处是数组的元素数量）。二分查找算法使用常数空间，对于任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管一些特定的、为了快速搜索而设计的数据结构更有效（比如[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8 "哈希表")），二分查找算法应用面更广。

二分查找算法有许多种变种。比如[分散层叠](https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%B1%82%E5%8F%A0&action=edit&redlink=1)可以提升在多个数组中对同一个数值的搜索的速度。分散层叠有效的解决了[计算几何学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6 "计算几何学")和其他领域的许多搜索问题。[指数搜索](https://zh.wikipedia.org/w/index.php?title=Exponential_search&action=edit&redlink=1)将二分查找算法拓宽到无边界的列表。[二叉搜索树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91 "二叉搜索树")和[B树](https://zh.wikipedia.org/wiki/B%E6%A0%91 "B树")数据结构就是基于[二分查找算法](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95 "二分查找算法")的。

# 2. 思想
二分搜索只对有序数组有效。二分搜索先比较数组中位元素和目标值。如果目标值与中位元素相等，则返回其在数组中的位置；如果目标值小于中位元素，则搜索继续在前半部分的数组中进行。如果目标值大于中位元素，则搜索继续在数组上部分进行。由此，算法每次排除掉至少一半的待查数组。

### 步骤

给予一个包含n个带值元素的数组$A$或是[记录](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BD%95 "记录")$A_{0},\cdots, A_{n-1}$，使${\displaystyle A_{0}\leq \cdots \leq A_{n-1}}$，以及目标值${\displaystyle T}$，还有下列用来查找${\displaystyle T}$在$\displaystyle A$中位置的[子程序](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BC%8F "子程序")。

1.  令 $L$ 为 0, $R$ 为 n - 1。
2.  如果 $L > R$，则查找以失败告终。
3.  令 m (中间值元素）为${\displaystyle \lfloor (L+R)/2\rfloor }$。（具体实现中，为防止[算术溢出](https://zh.wikipedia.org/wiki/%E7%AE%97%E8%A1%93%E6%BA%A2%E5%87%BA "算术溢出")，一般采用${\displaystyle \lfloor L+(R-L)/2\rfloor }$代替。）
4.  如果${\displaystyle A_{m}<T}$，令 L 为 m + 1 并回到步骤二。
5.  如果${\displaystyle A_{m}>T}$, 令 R 为 m - 1 并回到步骤二。
6.  当${\displaystyle A_{m}=T}$查找结束；回传值m。

这个[迭代](https://zh.wikipedia.org/wiki/%E7%96%8A%E4%BB%A3 "迭代")步骤会持续透过两个变量追踪搜索的边界。有些实际应用会在算法的最后放入相等比较，让比较循环更快，但平均而言会多一层迭代。

# 3. 复杂度分析
[时间复杂度](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

折半搜索每次把搜索区域减少一半，时间复杂度为$O\left(\log n\right)$。（n代表集合中元素的个数）

[空间复杂度](https://zh.wikipedia.org/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6 "空间复杂度")

$O\left(1\right)$。虽以递归形式定义，但是[尾递归](https://zh.wikipedia.org/wiki/%E5%B0%BE%E9%80%92%E5%BD%92 "尾递归")，可改写为循环。