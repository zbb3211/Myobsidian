# PARTⅠ：处理器
## Slide 2：流水线基础、流水线处理器、乱序执行【重要】
1.Pipeline基本概念与优缺点
- Inactive areas for one operation can be used for other operations
- 流水线基础小结
	- Pipelining consists in splitting a job in smaller “subjobs” and performing in parallel the “subjobs” on various pieces of data
	- Pipelining is extremely general to increase the throughput of a system (circuit, computer, network)
	- Pipelining does not improve latency (actually worsens it!)
	- Only effective where one has to repeat a job on many pieces of data (processor instructions)
--- 
2.流水线处理器
- 给几条指令，计算执行周期。
---
3.流水线冒险
- 数据冒险
	- RAW, WAR, WAW dependencies
	- Solution for RAW dependencies
		- Implement some logic in the processor to stop/repeat the decoding until the required value is available
		- “Stalling” roughly means introducing nops in the pipeline
		- If one stage is stalled (DDD), all the preceding ones must be stalled too (FFF)
		- ---
		- Data are available at the right time but in the wrong place
		- Add a forwarding path to bring it where it needs
		- Need logic to select (MUX) the right input to E stage
		- 5-stage pipeline with all forwarding paths: E->E, M->E, W->D
		- The register-file forwarding (W->D) is special case:
			- (In simple) During W, registers are written in the first half of the cycle
			- During D, registers are read in the second half of the cycle
- 结构冒险
	- Happens when different instructions compete for the same resources (e.g. pipeline stage)
	- It <font color="red">cannot happen</font> in this pipeline but in the next ones
	- If we did not stall instructions preceding 1004, we could have structural hazard
- 控制冒险
	- We fetch one instruction before we know which one!
	- 1st solution for control hazard
		- <font color="red">Stalling the pipeline</font> until which branch is discovered
	- 2nd solution for control hazard
		- We decide that two instructions following a branch are executed in any case (branch taken or not)
		- Instructions after the branches are called delay slots
		- Quite rare in current architectures
	- 3rd solution for control hazard (mainstream)
		- Guess the branch outcome and fetch the corresponding instruction
		- If the guess is correct, no cycle “penalty”
		- If the guess is wrong, what has been fetched and decoded is thrown away (“squashed”)
	- Branch predictors are extremely sophisticated
		- Dynamic predictors uses machine learning to learn previous experiences
		- Can be correct up to 99%
		- Therefore, delay slots become extremely rare
- 流水线处理小节
	- Simplest form of Instruction Level Parallelism(ILP)
	- Several instructions are now executed at once
	- Three types of hazards hinder pipelining
		- Data hazards (= data dependencies)
		- Solutions:
			- Forwarding paths, wherever possible 
			- Stalls, in all other cases
		- Control hazards (= jump and branches)
		- Solutions:
			- Delay slots, if architecture allows it
			- Branch prediction, guess and do the right thing
			- Stalls, if not
		- Structural hazards (= competing for a resource)
		- Solutions:
			- Rigid pipeline structure to prevent happening
			- Stalls, otherwise
---
4.乱序执行处理器结构，三种数据依赖，RS、ROB模块的作用和内容，了解寄存器重命名
- 三种数据依赖
	- RAW data hazards
		- Are the operands ready to start execution?
		- Old problem
	- WAR and WAW data hazards
		- The new data overwrite something which is still required?
		- WAW is a completely new problem – impossible before; WAR mostly will not occur
	- Rigid pipeline has no WAR and WAW hazards
	- WAR and WAW hazards for dynamic scheduling
- 寄存器重命名
	- Register renaming
		- WAW and WAR dependencies are called name dependencies
			- They do not carry a value (不传递结果) between two instructions
		- Often created by compilers to reuse the same registers
		- Can be removed by avoiding the use of the same “name”
			- Rename the destination register whenever a new value is created
			- Both the compiler (编译器) (statically) and the processor (dynamically) can do that
	- Register renaming by example
![[1677337537115.png]]
- 乱序执行处理器结构
![[1677336120508.png]]
![[1677337688576.png]]

- Reservation station (RS)
![[1677338177412.png]]
- The RS checks that the operands are available (RAW) and that the Execution Unit is free (structural hazard), than starts execution
![[1677338245262.png]]
- Unavailable operands are identified by the name and entry of the reservation station in charge of the originating instruction
- Implicit register renaming, thus removing WAR and WAW hazard
- New results are seen at their inputs through fast result buse
- Writeback into the registers can be done in-order or out-of-orde

- Re-order Buffer (ROB)
![[1677338790607.png]]
- Commit in-order the executed instructions
- Implemented through circular buff
![[1677339062861.png]]

## Slide 3 : 超标量、分支预测、多线程【了解】
1.超标量 : 超标量基本结构，超标量存在的问题
2.分支预测 : 静态与动态区别，动态如何通过历史来实现
3.多线程 : 多线程如何弥补超标量的不足，三种多线程工作方式，Cycle-by-cycle与blockwise MT的 优缺点
- 超标量体系结构的CPU在一个时钟周期可以同时分派（dispatching）多条指令在不同的执行单元中被执行，这就实现了指令级的并行。

