# 1. Introduction to Algorithm and Complexity
![[1677918453479.png]]
![[1677918511873.png]]

![[1677919050070.png]]
![[1677919253372.png]]
![[1678021414513.png]]



![[1677919500309.png]]

![[1677919565549.png]]

![[1677919772625.png]]

# 2. Minimum Spanning Tree & Minimum Steiner Tree
![[1677920192558.png]]

![[1677920597291.png]]


![[Pasted image 20230304170702.png]]
Prim时间复杂度:$O({|V|}^2)$，MST is in P


![[1677920948953.png]]


Kruskal时间复杂度：$O(ElogE)$

![[1677921654063.png]]

# 3. Path & Tour
**Euler Circuit**: a simple circuit that contains every edge in the graph.
**Euler Path**: a simple path that contains every edge in the graph.
欧拉路径：经过每一条边一次，但是不要求回到起始点 （包含图中每条边的路径）
欧拉回路：每条边恰好只走一次，并能回到出发点的路径（包含图中每条边的回路）
![[1677935141971.png]]
![[1677935241061.png]]
如果一个连通的多重图(至少有两个顶点)的每个顶点的度数都为偶数，则该图有一个欧拉回路
如果一个连通的多重图恰好有两个度数为奇数的顶点，则该图有一个欧拉路径

![[1678029404927.png]]

**Hamiltonian Circuit / Hamilton Cycle (Path)** is a simple circuit (Path) that passes through each vertex exactly once in the graph. A graph is Hamiltonian if it has a Hamiltonian Circuit.
若一条路径仅通过图中每一个顶点一次，则称这条路径为哈密顿路径.闭合的哈密顿路径称作哈密顿回路
![[1677937032476 1.png]]

![[1677935946379.png]]

## Traveling Salesman Problem
![[1677937187176.png]]
**Traveling Salesman Problem (TSP)** asks for a minimum Hamiltonian Circuit in a weighted complete graph.
旅行商问题(TSP)要找一个加权完全图中的最小哈密顿回路

## The double-tree algorithm
![[1677937432959.png]]
![[1677937982580.png]]

## Matching
![[1677938054202.png]]





# 4. Matching
![[1677938816192.png]]
在图论中，一个图是一个匹配（或称独立边集）是指这个图之中，任意两条边都没有公共的顶点。这时每个顶点都至多连出一条边，而每一条边都将一对顶点相匹配。
Maximal Matching （极大匹配）:添加任意一条边后都不再是匹配的匹配
Maximum matching （最大匹配）: 边数最多的匹配
Perfect Matching （完美匹配）：包含了图中所有顶点的匹配
![[1677939424984.png]]


![[1677939947126.png]]
![[1677939971861.png]]

![[1677939997696.png]]
![[1677940039712.png]]
针对每条边进行假设

## Bipartite graph
A **bipartite graph** (also called a bi-graph) is a graph whose vertices can be divided into two disjoint sets, such that no two vertices within the same set are adjacent.

![[1678002055722.png]]

对于二部图的任意一个顶点子集，它的邻域至少与它本身一样大

## Gale–Shapley algorithm
![[1678002342075.png]]
![[1678002463312.png]]

![[1678002495535.png]]
G-S algorithm 
	- always returns a stable matching.
	- more friendly to Boys

## Tutte's Theorem
![[1678003872471.png]]
![[1678004084022.png]]

![[1678003792186.png]]
1.首先判断点数是否为偶数
2.Tutte定理：对于任意一组顶点的删除，剩余的子图中奇数顶点的连通分量不超过删除的顶点数。

## Vertex Cover
![[1678004871622.png]]
![[Pasted image 20230305163049.png]]
定义：顶点覆盖是一组触及所有边的顶点(其余的顶点形成一个独立的集合)
在任何图中，顶点覆盖的大小都不小于匹配的大小。（因为顶点覆盖必须覆盖每条边，为了覆盖所有 匹配的边，我们必须用相同大小的顶点覆盖）

![[1678005186929.png]]
![[1678005237932.png]]

## Algorithm for maximum matching in bipartite graph
![[1678005421785.png]]
![[1678005571013.png]]
![[1678005586778.png]]

## Maximum matching in general graph
![[1678005614692.png]]


# 5. 高效数据建模处理与分析
![[1678007108334.png]]


## 贪婪算法
![[1678007692823.png]]
![[1678007760107.png]]


# 6. Flow
## Max Flow Problem
![[1678008314124.png]]
![[1678008441180.png]]

## Residual Graph
![[1678010292018.png]]

## Augmenting Path
![[1678010439410.png]]
![[1678010771274.png]]

## Ford-Fulkerson Algorithm
![[1678010832901.png]]
Ford and Fulkerson do not specify the approach to finding an augmenting path.
福特-富尔克森没有具体说明寻找增强路径的方法。
Theorem. The current flow is maximum if there is no augmenting path in the residual graph. 如果剩余图中没有增广路径，则当前流量最大。


## Max Flow v.s. Max Matching
Theorem. Maximum matching can be reduced to max flow in polynomial time.

## Tink about the multiple case
![[1678011272134.png]]

Theorem. The current flow is maximum iff there is no augmenting path in the residual graph


# 7. Cut
![[1678017494062.png]]
![[1678017894660.png]]

## Max-Flow v.s. Min-Cut
![[1678018028829.png]]
![[1678018314666.png]]
![[1678018487490.png]]
![[1678018888651.png]]


## Max-flow min-cut theorem
![[1678018991796.png]]

![[1678019056642.png]]
![[1678019079634.png]]

## Min Cut Algorithm
![[1678019608401.png]]

## Max Cut
![[1678019985315.png]]
## A naive approximation algorithm
![[1678020084592.png]]

![[1678020110976.png]]

![[1678020124820.png]]

# 8. Scheduling
## Scheduling on a single machine
![[1678020538351.png]]

## Scheduling on identical parallel machines
![[1678020598666.png]]



## A local Search Algorithm
![[1678020694551 1.png]]
![[1678020776761.png]]



# 9. Knapsack Problem
![[1678021004716.png]]


## Solve Knapsack via Dynamic Programming
![[1678021108605.png]]

![[1678021139101.png]]


![[1678021245700.png]]

![[1678021309774.png]]


